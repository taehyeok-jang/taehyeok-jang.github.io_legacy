<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>(Paper Review) Algorithms Behind Modern Storage Systems | Keep Calm and HAKUNA MATATA</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="(Paper Review) Algorithms Behind Modern Storage Systems">
<meta name="author" content="taehyeok-jang">
<meta property="og:locale" content="en_US">
<meta name="description" content="이 글은 Apache Cassandra의 commiter인 Alex Petrov가 작성한 논문 “Algorithms Behind Modern Storage Systems: Different uses for read-optimized B-trees and write-optimized LSM-trees”을 읽고 추가적으로 정리한 글입니다.">
<meta property="og:description" content="이 글은 Apache Cassandra의 commiter인 Alex Petrov가 작성한 논문 “Algorithms Behind Modern Storage Systems: Different uses for read-optimized B-trees and write-optimized LSM-trees”을 읽고 추가적으로 정리한 글입니다.">
<link rel="canonical" href="/jekyll-theme-yat/database/2020/09/27/algorithms-behind-modern-storage-systems.html">
<meta property="og:url" content="/jekyll-theme-yat/database/2020/09/27/algorithms-behind-modern-storage-systems.html">
<meta property="og:site_name" content="Keep Calm and HAKUNA MATATA">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-09-27T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="(Paper Review) Algorithms Behind Modern Storage Systems">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"taehyeok-jang"},"dateModified":"2020-09-27T00:00:00+00:00","datePublished":"2020-09-27T00:00:00+00:00","description":"이 글은 Apache Cassandra의 commiter인 Alex Petrov가 작성한 논문 “Algorithms Behind Modern Storage Systems: Different uses for read-optimized B-trees and write-optimized LSM-trees”을 읽고 추가적으로 정리한 글입니다.","headline":"(Paper Review) Algorithms Behind Modern Storage Systems","mainEntityOfPage":{"@type":"WebPage","@id":"/jekyll-theme-yat/database/2020/09/27/algorithms-behind-modern-storage-systems.html"},"url":"/jekyll-theme-yat/database/2020/09/27/algorithms-behind-modern-storage-systems.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/jekyll-theme-yat/assets/css/main.css">
  <script src="/jekyll-theme-yat/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/jekyll-theme-yat/feed.xml" title="Keep Calm and HAKUNA MATATA">
<script>
  function initGoogleAnalytics() {
    var doNotTrack = (window.doNotTrack === "1" || navigator.doNotTrack === "1" ||
      navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1");
    var enableDNT = "true" == "true";

    if (!enableDNT || !doNotTrack) {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'G-WWZ625TGVC', 'auto');
      ga('send', 'pageview');
    }
  }
  window.addEventListener("load", initGoogleAnalytics);
</script>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/jekyll-theme-yat/">
  <img class="site-favicon" title="Keep Calm and HAKUNA MATATA" src="" onerror="this.style.display='none'">
  Keep Calm and HAKUNA MATATA
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/jekyll-theme-yat/about.html">ABOUT</a><a class="page-link" href="/jekyll-theme-yat/archives.html">ARCHIVES</a><a class="page-link" href="/jekyll-theme-yat/categories.html">CATEGORIES</a><a class="page-link" href="/jekyll-theme-yat/">HOME</a><a class="page-link" href="/jekyll-theme-yat/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">(Paper Review) Algorithms Behind Modern Storage Systems</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2020-09-27T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 27, 2020
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 7 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/jekyll-theme-yat/tags.html#paper-review">#paper-review</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#database">#database</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#b-tree">#b-tree</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#lsm-tree">#lsm-tree</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p>이 글은 Apache Cassandra의 commiter인 Alex Petrov가 작성한 논문 “Algorithms Behind Modern Storage Systems: Different uses for read-optimized B-trees and write-optimized LSM-trees”을 읽고 추가적으로 정리한 글입니다.</p>

<h2 id="introduction">Introduction</h2>

<p>어플리케이션으로부터 생성되는 데이터 양은 점점 증가하여 이를 저장하기 위한 storage를 확장하는 것은 더욱 도전적인 문제가 되었습니다. 각 데이터베이스 시스템은 성능 상 고유의 trade-off가 있기 때문에 그들의 원리를 잘 이해하고 사용하는 것은 중요합니다. 각 어플리케이션은 read/write 접근 패턴, 요구되는 일관성 수준과 latency 등이 상이하기 때문에 어플리케이션 설계 시 이들의 특성을 잘 이해하고 가장 최적화된 데이터베이스를 선택해야 합니다. 2020년 Stack Overflow Developer Survey에 따르면 주로 사용되는 데이터베이스로 관계형 데이터베이스인 MySQL, PostgreSQL부터 NoSQL 데이터베이스인 Cassandra 등 아주 다양합니다. 각각의 데이터베이스는 고유의 특성을 가지고 있지만 이들의 핵심 구동원리에 해당하는 자료구조는 세부 사항을 제외한다면 몇가지로 정해져있습니다. 그러므로 이 자료구조들을 잘 이해하고 있으면 각 데이터베이스의 원리와 특성에 대해서도 쉽게 알 수 있을 것입니다. 이번 글에서는 대부분의 현대 데이터베이스 시스템에서 사용되고 있는 두가지 큰 storage system인 B-Tree, LSM-Tree와 각각의 use case, trade-off를 알아보겠습니다.</p>

<h2 id="b-tree">B-Tree</h2>

<p>B-Tree는 read optimized 자료구조로서 balanced binary tree의 확장된 형태입니다. 수많은 변형이 있으며 여러 데이터베이스(MySQL InnoDB, PostgreSQL)와 파일 시스템(HFS+, HTrees in ext4)에서도 사용되고 있습니다. B-Tree의 개념에 대해서 쉽게 이해하기 위해서 아래 자료를 참조할 것을 추천합니다.</p>

<p><a href="https://www.cs.princeton.edu/courses/archive/fall06/cos226/lectures/balanced.pdf">https://www.cs.princeton.edu/courses/archive/fall06/cos226/lectures/balanced.pdf</a>
<a href="https://1.bp.blogspot.com/-am75dhLjeK8/X3E2XYlDv5I/AAAAAAAADoo/RF1sD1P8Waw4j8oP2N2G4Oh-qr2d1txiQCLcBGAsYHQ/s1572/b-tree.png"><img src="https://1.bp.blogspot.com/-am75dhLjeK8/X3E2XYlDv5I/AAAAAAAADoo/RF1sD1P8Waw4j8oP2N2G4Oh-qr2d1txiQCLcBGAsYHQ/w400-h195/b-tree.png" alt="img"></a></p>

<p>위 자료에서는 가장 기본적인 tree 자료구조인 binary tree부터 balanced tree인 red-black tree, 그리고 이들이 일반화된 형태인 2-3-4 tree, B-Tree를 다루고 있습니다. B-Tree는 node 당 지정된 개수의 link를 가진 balanced tree라고 할 수 있겠습니다. B-Tree를 개선한 B+ Tree는 inner node에는 데이터가 없고 external node(leaf node)에만 데이터를 저장하고 있습니다. 하나의 disk block에 더 많은 inner node를 배치할 수 있어 탐색 시 B-Tree에 비하여 더 적은 disk block을 읽으므로 B-Tree에 비해 상대적으로 나은 성능을 보입니다.</p>

<p>B-Tree의 성질은 다음과 같습니다.</p>
<ul>
  <li>Sorted</li>
  <li>Self-balancing. insertion 시에 overflow 혹은 deletion 시에 일정 수준의 occupancy가 떨어지는 것을 확인하여 node 분할 혹은 합병합니다</li>
  <li>Guarantee of logarithmic lookup time</li>
  <li>Mutable</li>
</ul>

<p>B-Tree 계열 자료구조의 중요한 가치는 file system과 같은 block-oriented storage context에서 검색을 효율적으로 할 수 있다는 것입니다. binary tree에 비해서 B-Tree에서는 한 node에서 child node를 탐색하기 위한 link 수가 훨씬 많으므로 탐색 과정에서 page access를 위한 I/O 횟수가 줄어들기 때문에 비용 효율적입니다.</p>

<h2 id="lsm-tree">LSM-Tree</h2>

<p>LSM-Tree (log-structured merge tree)는 write optimized 된 immutable, disk-resident 한 자료구조이며 read 보다 write가 더 빈번한 시스템에서 우수한 성능을 가집니다. Google Bigtable, HBase, LevelDB, Apache Cassandra 등의 데이터베이스에서 사용되고 있습니다. 현재 LSM-Tree가 더 인기를 얻는 것은 디스크 성능을 저하시키는 update-in-place write인 random insert, update, delete를 없애고 append-only write를 통해 write 효율을 최대한으로 높였기 때문입니다.</p>

<h3 id="anatomy-of-lsm-tree">Anatomy of LSM-Tree</h3>

<p>sequential write를 허용하기 위해서, 즉 file system 상에서 write를 sequential하게 동작하게 하기 위해서 LSM-Tree는 write, update를 우선 in-memory table인 memtable에 batch 형태로 저장합니다. memtable 내 자료구조는 binary search tree나 skip list, 혹은 sorted balanced tree인 avl tree 등을 사용합니다. batch 크기가 다 차면 한번에 disk로 저장(flush)합니다. 데이터를 retrieve 할 때는 memtable과 디스크 내 테이블을 찾아보아야 하며 결과를 돌려주기 전에 merge를 수행합니다.</p>

<p><a href="https://1.bp.blogspot.com/-slWHSy63a3c/X3E2yPKWICI/AAAAAAAADow/0lghKH0dZLwzP5fM3O7eJq4ojtOL59aywCLcBGAsYHQ/s1430/lsm-tree-01.png"><img src="https://1.bp.blogspot.com/-slWHSy63a3c/X3E2yPKWICI/AAAAAAAADow/0lghKH0dZLwzP5fM3O7eJq4ojtOL59aywCLcBGAsYHQ/w640-h180/lsm-tree-01.png" alt="img"></a></p>

<p>위 과정을 정리하면 다음과 같습니다.</p>

<ol>
  <li>새로운 write를 memtable에 저장합니다</li>
  <li>memtable의 batch threshold를 초과하면, 디스크 상의 SSTable로 flush 합니다. 데이터가 디스크에 flush 되는 동안 새로운 write는 memtable에 계속 추가됩니다</li>
  <li>read 시에는 먼저 memtable을 찾아보고, 없으면 가장 최근의 SSTable부터 탐색합니다. 주어진 key에 해당하는 데이터는 여러 SSTable에 존재하는데 timestamp를 기반으로 저장 시점을 판단합니다</li>
  <li>read 시에 필요하다면 merge을 수행합니다</li>
</ol>

<h3 id="sstable-sorted-string-table">SSTable (Sorted String Table)</h3>

<p>현대 여러 LSM-Tree의 구현은 disk-resident table로서 SSTable을 사용하고 있으며, 그 이유로는 단순함 (read/write, search가 쉽다)과 병합 성질 (병합 중 SSTable scan과 병합된 결과의 write가 sequential 하다)이 있습니다. SSTable은 disk-resisdent ordered immutable 자료구조이며 key-storage 입니다. 구조적으로 data block과 index block으로 나누어져 있어 주로 sparse index 형태의 index block에 먼저 접근하여 data block으로 접근합니다. data block의 모든 value는 insert, update, delete가 수행된 시점의 timestamp를 가집니다.</p>

<p>SSTable은 다음과 같은 성질을 가집니다.</p>

<ul>
  <li>point query는 primary index를 찾음으로써 매우 빠르게 수행됩니다</li>
  <li>scan은 data block으로부터 key/value가 순차적으로 read되기 때문에 효율적으로 이루어질 수 있습니다</li>
</ul>

<p>SSTable은 memory-resident table이 flush에 의해 disk에 쓰이기 전 일종의 snapshot이라고 할 수 있습니다.</p>

<p><a href="https://1.bp.blogspot.com/-JqlWhSQoZ2g/X3E286XVbRI/AAAAAAAADo0/mBbIQtwGGT4WshAJ8WZ_yjdectyOWxvggCLcBGAsYHQ/s1292/lsm-tree-02.png"><img src="https://1.bp.blogspot.com/-JqlWhSQoZ2g/X3E286XVbRI/AAAAAAAADo0/mBbIQtwGGT4WshAJ8WZ_yjdectyOWxvggCLcBGAsYHQ/w640-h308/lsm-tree-02.png" alt="img"></a></p>

<h3 id="lookups">Lookups</h3>

<p>SSTable의 데이터를 retrieve 하는 과정을 살펴보겠습니다.</p>

<ul>
  <li>search all SSTables on disk</li>
  <li>check the memory-resident table</li>
  <li>merge their contents together before running the result</li>
</ul>

<p>검색된 data는 여러 SSTable에 있을 수 있기 때문에 read 중에 merge step을 포함하여 이들을 합칩니다. merge step은 update, delete에 대한 결과를 보장하기 위해서도 필요합니다. LSM-Tree에서 delete는 tombstone이라 불리는 placeholder를 insert 하는 것이고 insert는 더 큰 timestamp의 record힙니다. read 동안 record는 delete에 의해 shadow 되어 return 되지 않거나 더 큰 timestamp로 update 된 record를 return 합니다. 아래는 merge step이 서로 다른 SSTable의 데이터를 통합(reconcile)하는 과정을 보여줍니다.</p>

<p><img src="https://1.bp.blogspot.com/-9smBt85IgaM/X3E3FnlSnCI/AAAAAAAADo8/8h49TprKMgcd8tUFN0LWvw5r6nVodfShgCLcBGAsYHQ/w640-h262/lsm-tree-03.png" alt="img"></p>

<h3 id="bloom-filter">Bloom Filter</h3>

<p><a href="https://1.bp.blogspot.com/-bDvX0S_d3Go/X3E3PEb-BRI/AAAAAAAADpA/fY2bgZN3R0IW3A_B_42QYp2y-hpvsXBOACLcBGAsYHQ/s1252/lsm-tree-04.png"><img src="https://1.bp.blogspot.com/-bDvX0S_d3Go/X3E3PEb-BRI/AAAAAAAADpA/fY2bgZN3R0IW3A_B_42QYp2y-hpvsXBOACLcBGAsYHQ/w640-h104/lsm-tree-04.png" alt="img"></a></p>

<p>read 시에 검색 대상이 되는 SSTable의 개수를 줄이고 모든 SSTable에 대해서 주어진 key를 가지고 있는지 확인하는 것을 피하기 위해 여러 storage system은 Bloom filter라는 자료구조를 사용합니다. Bloom filter는 주어진 element가 set에 속하는지 아닌지 판단하기 위해 사용하는 확률적 자료구조이며 다음의 명제 두가지를 제공합니다.</p>

<ul>
  <li>might be in an SSTable (probabily produce false positive)</li>
  <li>is definitely not in an SSTable (definitely not produce false negative)</li>
</ul>

<p>Bloom filter의 세부 동작은 어떤 hash function을 몇개 사용하는지, filter는 몇 bit 인지, 총 몇개의 element가 insert 되는지에 따라 결정됩니다. 더 큰 filter를 사용할수록 false positive, 즉 might be in an SSTable 케이스의 확률은 줄어들지만 space complexity가 증가하는 trade-off가 있습니다. Bloom filter에 대해서 직관적으로 이해하기 위해서 아래 링크에서 예제를 시도해보기를 추천합니다.</p>

<p><a href="https://llimllib.github.io/bloomfilter-tutorial/">https://llimllib.github.io/bloomfilter-tutorial/</a></p>

<h3 id="lsm-tree-maintenance">LSM-Tree Maintenance</h3>

<p><a href="https://1.bp.blogspot.com/-XnwOTWcyxnU/X3E3h_UK2bI/AAAAAAAADpM/qZ_HrH8IYUQUqLCnjLJblyjltcYbXpkUwCLcBGAsYHQ/s1395/LSM_Tree.png"><img src="https://1.bp.blogspot.com/-XnwOTWcyxnU/X3E3h_UK2bI/AAAAAAAADpM/qZ_HrH8IYUQUqLCnjLJblyjltcYbXpkUwCLcBGAsYHQ/w640-h322/LSM_Tree.png" alt="img"></a></p>

<p>LSM-Tree 내에서 SSTable들은 계층 구조를 이루고 있으며 같은 level의 SSTable은 동일한 크기를 가집니다. SSTable에 충분한 데이터가 쌓이면 상위 level을 향해 compaction이 발생하고, 기존 SSTable의 데이터는 없어지고 상위 level의 새로운 SSTable에 데이터가 쓰여집니다. 각 SSTable은 key를 기준으로 정렬되어있기 때문에 compaction은 merge sort 방식으로 매우 효율적으로 동작합니다.</p>

<ul>
  <li>여러 SSTable로부터 sequential 하게 read 됩니다</li>
  <li>병합 결과 SSTable 또한 sequential 하게 write 됩니다</li>
  <li>merge sort는 memory에 모두 적재할 수 없는 큰 파일에서도 잘 동작합니다</li>
  <li>stable sort 이므로 기존 record의 순서를 보존합니다</li>
</ul>

<h2 id="atomicity-and-durability">Atomicity and Durability</h2>

<p>B-Tree와 LSM-Tree에서 I/O operation의 수를 줄이고 sequential하게 이루어지도록 하기 위해 실제 update를 하기 전 memory에 operation들을 batch 형태로 저장하고 있습니다. 이는 시스템에 장애가 발생했을 때 data integrity가 보장되지 않을 수 있으며 atomicity, durability 를 확신할 수 없다는 것을 암시합니다.</p>

<p>이 문제를 해결하기 위해서 대부분의 현대 데이터베이스 시스템에서는 WAL (write-ahead log)를 사용합니다. WAL의 핵심 아이디어는 모든 상태 변화를 disk 상의 append-only log로 남기는 것입니다. 이는 장애 상황에서도 WAL을 replay하여 이전의 상태를 재현 가능하다는 것을 의미합니다.</p>

<p>B-Tree에서 WAL은 반드시 로그를 남긴 뒤에만 데이터 파일에 변경 사항을 적용하는 것으로 사용합니다. 비교적 작은 크기의 WAL을 남기며 data page에 적용되지 않은 변경 사항을 WAL을 통해 재현 가능합니다. LSM-Tree에서는 WAL이 memtable에는 적용되었으나 disk에 완전히 flush 되지 않은 변경사항을 저장하기 위해 사용됩니다. memtable이 flush 되어 새로운 read가 새로 생성된 SSTable에서 이루어지는 시점부터 해당 segment는 제거됩니다.</p>

<h2 id="summary">Summary</h2>

<p>B-Tree와 LSM-Tree의 차이는 요약하자면 read/write 중 어떤 operation에 최적화 되어있고 이를 위해 각 시스템은 어떻게 동작하는지에 초점이 맞춰져 있습니다. 둘의 성질을 비교하면 아래와 같습니다.</p>

<p>B-Tree.</p>

<ul>
  <li>read optimized</li>
  <li>mutable</li>
  <li>write는 연쇄적인 (cascaded) node split을 발생시킬 수 있으며 이는 write operation을 더 무겁게 합니다</li>
  <li>byte adressing이 불가능한 page environment (block storage)에 최적화 되어있습니다</li>
  <li>빈번한 update에 의한 fragmentation이 발생할 수 있으며 추가적인 maintenance와 block rewrite를 요구합니다. 하지만 LSM-Tree의 maintenance 보다 가볍습니다</li>
  <li>concurrent access는 reader/writer isolation을 요구하며 lock, latch의 chain을 포함합니다</li>
</ul>

<p>LSM-Tree.</p>

<ul>
  <li>write optimized</li>
  <li>immutable. 디스크에 한번 write 되면 절대 update 되지 않습니다. immutable에서 오는 장점 중 하나는 flush 된 table에 대해서 concurrent access가 가능하다는 점입니다</li>
  <li>read는 여러 source (SSTable)을 거쳐야 하며 merge process를 거칠 수 있습니다</li>
  <li>buffered write가 disk에 flush 되어야 하므로 maintenance/compaction이 요구됩니다</li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li>Alex Petrov, 2018. Algorithms Behind Modern Storage Systems: Different uses for read-optimized B-trees and write-optimized LSM-trees. Queue; (https://dl.acm.org/doi/10.1145/3212477.3220266)</li>
  <li><a href="https://insights.stackoverflow.com/survey/2020#technology-databases-all-respondents4">Stack Overflow Developer Survey, 2020</a></li>
  <li>B-Tree
    <ul>
      <li>https://en.wikipedia.org/wiki/B-tree</li>
      <li>https://www.cs.princeton.edu/courses/archive/fall06/cos226/lectures/balanced.pdf</li>
      <li>https://docs.microsoft.com/en-us/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver15</li>
      <li>https://www.tutorialspoint.com/difference-between-clustered-index-and-non-clustered-index-in-sql-server</li>
    </ul>
  </li>
  <li>LSM-Tree
    <ul>
      <li>https://en.wikipedia.org/wiki/Log-structured_merge-tree</li>
      <li>https://yetanotherdevblog.com/lsm/</li>
      <li>https://medium.com/swlh/log-structured-merge-trees-9c8e2bea89e8</li>
    </ul>
  </li>
  <li>Bloom filter
    <ul>
      <li>https://en.wikipedia.org/wiki/Bloom_filter</li>
      <li>https://llimllib.github.io/bloomfilter-tutorial/</li>
      <li>https://yetanotherdevblog.com/bloom-filters/</li>
    </ul>
  </li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/jekyll-theme-yat/stream-processing/2020/09/23/decaton-02.html" title="Decaton - High performance stream processing framwork based on Apache Kafka - Part 2">Decaton - High performance stream processing...</a><a class="next" href="/jekyll-theme-yat/distributed-systems/2020/10/18/map-reduce-performance-tunings.html" title="MapReduce - Performance Tunings">MapReduce - Performance Tunings</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/jekyll-theme-yat/distributed-systems/2020/10/18/map-reduce-performance-tunings.html" title="MapReduce - Performance Tunings">MapReduce - Performance Tunings</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/gatech/2024/01/08/cse6250-1-intro-to-bd4h.html" title="MapReduce - Performance Tunings">CSE6250 Big Data for Healthcare - 1. Intro</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/distributed-systems/2022/01/03/api-design-in-distributed-systems.html" title="MapReduce - Performance Tunings">API Design in Distributed Systems</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/distributed-systems/2020/08/09/paper-review-map-reduce.html" title="MapReduce - Performance Tunings">(Paper Review) MapReduce - Simplified Data Processing on Large Clusters</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-theme-yat/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2024 TaeHyeok Jang</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/jekyll-theme-yat/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
